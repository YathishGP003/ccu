From eef09cc9a3c8ed83cd5603ca6a391897ccfa99ab Mon Sep 17 00:00:00 2001
From: mkundaragi <mkundaragi@75f.io>
Date: Wed, 15 Jun 2022 12:32:58 +0000
Subject: [PATCH 14/50] Merged PR 4110: Alert not resolving

Alert not resolving

Related work items: #11640
---
 .../java/a75f/io/alerts/AlertManager.java     |  2 ++
 .../java/a75f/io/alerts/AlertProcessor.java   |  7 ++---
 .../java/a75f/io/alerts/AlertsRepository.kt   | 31 ++++++++++++++-----
 .../main/java/a75f/io/alerts/Conditional.java |  6 ++--
 .../a75f/io/alerts/model/AlertsModelUtil.kt   |  3 --
 5 files changed, 30 insertions(+), 19 deletions(-)

diff --git a/alerts/src/main/java/a75f/io/alerts/AlertManager.java b/alerts/src/main/java/a75f/io/alerts/AlertManager.java
index 9a6ce8c3b..7cd20ccec 100644
--- a/alerts/src/main/java/a75f/io/alerts/AlertManager.java
+++ b/alerts/src/main/java/a75f/io/alerts/AlertManager.java
@@ -1,6 +1,7 @@
 package a75f.io.alerts;
 
 import android.content.Context;
+import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -121,6 +122,7 @@ public class AlertManager
     }
 
     public void processAlerts() {
+        Log.i("CCU_ALERTS", "processAlerts: ");
         if (! repoCheck()) return;
         repo.processAlertDefs();
     }
diff --git a/alerts/src/main/java/a75f/io/alerts/AlertProcessor.java b/alerts/src/main/java/a75f/io/alerts/AlertProcessor.java
index 13027421f..cbcf572dc 100644
--- a/alerts/src/main/java/a75f/io/alerts/AlertProcessor.java
+++ b/alerts/src/main/java/a75f/io/alerts/AlertProcessor.java
@@ -8,7 +8,6 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
@@ -48,7 +47,6 @@ public class AlertProcessor
      * Called from AlertRepo upon AlertProcessJob.doJob.
      */
     public List<AlertDefOccurrence> evaluateAlertDefinitions(List<AlertDefinition> alertDefs) {
-        CcuLog.d("CCU_ALERTS", "processAlerts with count " + alertDefs.size());
         List<AlertDefOccurrence> occurrences = new ArrayList<>();
 
         for (AlertDefinition def : alertDefs) {
@@ -59,8 +57,10 @@ public class AlertProcessor
 
             Conditional.GrpOperator alertDefType = Conditional.GrpOperator.fromValue(def.conditionals.get(0).grpOperation); // See the note in ::inspectAlertDef regarding unique grpOperations
             def.evaluate(defaultSharedPrefs);
+
             if (alertDefType.equals(Conditional.GrpOperator.EQUIP) || alertDefType.equals(Conditional.GrpOperator.DELTA)) {
-                occurrences.addAll(processForEquips(def));
+                List<AlertDefOccurrence> retunredList = processForEquips(def);
+                occurrences.addAll(retunredList);
             } else {
                 occurrences.add(process(def));
             }
@@ -101,7 +101,6 @@ public class AlertProcessor
      */
     private List<AlertDefOccurrence> processForEquips(AlertDefinition def) {
         Map<String, String> equipToPoint = new HashMap<>();
-
         // Find all the equips spread across the conditionals and initialize the results map
         Map<String, Boolean> equipToResult = def.conditionals.stream()
                 .flatMap(c -> c.equipToStatus.keySet().stream())
diff --git a/alerts/src/main/java/a75f/io/alerts/AlertsRepository.kt b/alerts/src/main/java/a75f/io/alerts/AlertsRepository.kt
index f4555126f..8407d86b9 100644
--- a/alerts/src/main/java/a75f/io/alerts/AlertsRepository.kt
+++ b/alerts/src/main/java/a75f/io/alerts/AlertsRepository.kt
@@ -6,6 +6,7 @@ import a75f.io.alerts.model.AlertDefProgress.Partial
 import a75f.io.api.haystack.Alert
 import a75f.io.api.haystack.CCUHsApi
 import a75f.io.logger.CcuLog
+import android.util.Log
 import io.reactivex.rxjava3.core.Completable
 import io.reactivex.rxjava3.disposables.Disposable
 import io.reactivex.rxjava3.schedulers.Schedulers
@@ -119,7 +120,7 @@ class AlertsRepository(
 
    // "Resolve" an alert
    fun fixAlert(alert: Alert) {
-      CcuLog.d("CCU_ALERTS", "Fix Alert!")
+
       alert.setEndTime(DateTime().millis)
       alert.setFixed(true)
       alert.setSyncStatus(false)
@@ -199,26 +200,29 @@ class AlertsRepository(
 
       // evaluate and raise alert conditions from alert defs
       alertDefOccurrences = alertProcessor.evaluateAlertDefinitions(alertDefs)
+      fixNewStateAlerts(alertDefOccurrences)
 
       // update overall state of raised alerts
       alertDefsState += alertDefOccurrences
 
-      // Fix internal event alerts (i.e. "CCU RESTART", "CM_REINIT", etc.) that have been active for > 1 hour
-      fixExpiredEventAlerts()
 
-      CcuLog.d("CCU_ALERTS", "New AlertDefsState = ${alertDefsState.niceString()}")
+      // Fix internal event alerts (i.e. "CCU RESTART", "CM_REINIT", etc.) that have be
+      //
+      // en active for > 1 hour
+      fixExpiredEventAlerts()
 
       // update active alerts with new state
       val alertsStateChange = dataStore.getActiveAlerts() - alertDefsState
 
-      CcuLog.d("CCU_ALERTS", "New AlertsState = $alertsStateChange")
-
       // commit changes
       alertsStateChange.newAlerts
          .map { occurrence ->  occurrence.toAlert(haystack) }
          .forEach { alert -> addAlert(alert)
       }
-      alertsStateChange.newlyFixedAlerts.forEach { alert -> fixAlert(alert) }
+      alertsStateChange.newlyFixedAlerts.forEach { alert ->
+         Log.i("DEV_DEUG", "Hard Fix: $alert")
+              fixAlert(alert)
+      }
 
       // check for alert time-out
       clearElapsedAlerts()
@@ -227,7 +231,7 @@ class AlertsRepository(
       syncAlerts()
    }
 
-   // data structure used by AlertDefs dev settings fragment
+   // data structure used by AlertDefs dev settings fragment0
    fun getOffsetCounter(): Map<AlertDefOccurrence, Int> {
       val mapping = mutableMapOf<AlertDefOccurrence, Int>()
 
@@ -242,10 +246,21 @@ class AlertsRepository(
    fun getCurrentOccurrences() = alertDefOccurrences
 
 
+
+   private fun fixNewStateAlerts(alertDefList: List<AlertDefOccurrence> ){
+      alertDefList.forEach {
+         if(!it.testPositive && !it.alertDef.alert.isFixed){
+            fixAlert(it.alertDef.alert)
+         }
+      }
+   }
+
    /////   private   /////
 
    private fun fixExpiredEventAlerts() {
+      Log.i("CCU_ALERTS", "fixExpiredEventAlerts: ")
       val alerts = dataStore.getActiveInternalEventAlerts()
+      Log.i("CCU_ALERTS", "fixExpiredEventAlerts: $alerts")
       for (a in alerts) {
          if (!a.isFixed && (System.currentTimeMillis() - a.startTime) >= 3600000) {
             CcuLog.i("CCU_ALERTS", "Fixing expired event alert: $a")
diff --git a/alerts/src/main/java/a75f/io/alerts/Conditional.java b/alerts/src/main/java/a75f/io/alerts/Conditional.java
index 28cf4c919..d24d8de7e 100644
--- a/alerts/src/main/java/a75f/io/alerts/Conditional.java
+++ b/alerts/src/main/java/a75f/io/alerts/Conditional.java
@@ -382,7 +382,6 @@ public class Conditional
                     
                     HisItem reading1 = hisItems.get(hisItems.size() - 2);
                     HisItem reading2 = hisItems.get(hisItems.size() - 1);
-    
                     if (value.contains("zone")) {
                         val = String.valueOf(CCUHsApi.getInstance().readHisValByQuery(value+" and equipRef == \"" + equipRef + "\""));
                                                     sb.append("\nval (RHS): ").append(val).append("  -- recalculated for this zone");
@@ -393,10 +392,8 @@ public class Conditional
                         reading1 = reading2 ;
                                                     sb.append("\nOlder his reading is more than 65 sec old, so setting readings to the same");
                     }
-
                     resVal = reading1.getVal() - reading2.getVal();
                                                sb.append("\n   resVal (LHS): ").append(resVal).append("  -- difference between readinngs.");
-
                     Expression expression = new Expression(resVal+ " "+condition+" " + val);
                     CcuLog.d("CCU_ALERTS", " expression "+expression.toString());
                                                 sb.append("\n").append(expression).append(": ");
@@ -404,6 +401,7 @@ public class Conditional
                     boolean status = expression.eval().intValue() > 0;
                     equipToPoint.put(equipRef, pointRef);
                     equipToStatus.put(equipRef, status);
+
                     if (status) {
                                                     sb.append("TRUE");
                         CcuLog.d("CCU_ALERTS", " Add to pointList");
@@ -413,7 +411,7 @@ public class Conditional
                         lastValue.add(new PointVal(pointRef, reading1.getVal()));
                         presentValue.add(new PointVal(pointRef, reading2.getVal()));
                     } else {
-                                                    sb.append("FALSE");
+                        sb.append("FALSE");
                     }
                 }
                                             sb.append("\nAfter Equips, have point list size ").append(pointList.size());
diff --git a/alerts/src/main/java/a75f/io/alerts/model/AlertsModelUtil.kt b/alerts/src/main/java/a75f/io/alerts/model/AlertsModelUtil.kt
index 346bf8393..40eec56ec 100644
--- a/alerts/src/main/java/a75f/io/alerts/model/AlertsModelUtil.kt
+++ b/alerts/src/main/java/a75f/io/alerts/model/AlertsModelUtil.kt
@@ -2,8 +2,6 @@ package a75f.io.alerts.model
 
 import a75f.io.alerts.AlertDefinition
 import a75f.io.api.haystack.Alert
-import a75f.io.logger.CcuLog
-import java.lang.StringBuilder
 
 /**
  * Miscellaneious data classes, typealiases, extensions, and utility functions for Alerts Kt
@@ -66,7 +64,6 @@ operator fun List<Alert>.minus(alertDefsState: AlertDefsState): AlertsStateChang
       .filter { ! this.contains(it) }
    val fixedAlerts = alertDefsState.getFixedAlerts()
       .filter { this.contains(it) } .map { this.find(it)!! }
-
    return AlertsStateChange(newAlerts = newAlerts, newlyFixedAlerts = fixedAlerts)
 }
 
-- 
2.31.0.windows.1

