package a75f.io.renatus.profiles.systemimport a75f.io.api.haystack.CCUHsApiimport a75f.io.api.haystack.Tagsimport a75f.io.device.mesh.DeviceUtilimport a75f.io.device.mesh.MeshUtilimport a75f.io.domain.api.Domainimport a75f.io.domain.api.DomainNameimport a75f.io.domain.logic.hasChangesimport a75f.io.domain.util.CommonQueriesimport a75f.io.domain.util.ModelLoaderimport a75f.io.logger.CcuLogimport a75f.io.logic.Globalsimport a75f.io.logic.Limport a75f.io.logic.bo.building.dab.DabProfile.CARRIER_PRODimport a75f.io.logic.bo.building.definitions.ProfileTypeimport a75f.io.logic.bo.building.hvac.ModulatingProfileAnalogMappingimport a75f.io.logic.bo.building.hvac.ModulatingProfileRelayMappingimport a75f.io.logic.bo.building.system.dab.DabFullyModulatingRtuimport a75f.io.logic.bo.building.system.setFanTypeToStagesimport a75f.io.logic.bo.building.system.vav.config.DabModulatingRtuProfileConfigimport a75f.io.logic.bo.haystack.device.ControlMoteimport a75f.io.logic.bo.util.DesiredTempDisplayModeimport a75f.io.renatus.BuildConfigimport a75f.io.renatus.compose.showErrorDialogimport a75f.io.renatus.profiles.oao.updateOaoPointsimport a75f.io.renatus.profiles.profileUtils.UnusedPortsModelimport a75f.io.renatus.profiles.system.advancedahu.Optionimport a75f.io.renatus.util.ProgressDialogUtilsimport a75f.io.renatus.util.highPriorityDispatcherimport android.content.Contextimport android.text.Htmlimport androidx.lifecycle.viewModelScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextopen class DabModulatingRtuViewModel : DModulatingRtuViewModel() {    var minMaxVoltage = List(11) { Option(it, it.toString()) }    fun init(context: Context, hayStack: CCUHsApi) {        super.init(context, ModelLoader.getDabModulatingRtuModelDef(), hayStack)        val systemEquip = hayStack.readEntity(CommonQueries.SYSTEM_PROFILE)        CcuLog.i(Domain.LOG_TAG, "Current System Equip $systemEquip")        if (systemEquip["profile"].toString() == "dabFullyModulatingAhu"            || systemEquip["profile"].toString() == ProfileType.SYSTEM_DAB_ANALOG_RTU.name        ) {            CcuLog.i(Domain.LOG_TAG, "Get active config for dabFullyModulatingAhu")            profileConfiguration = DabModulatingRtuProfileConfig(model).getActiveConfiguration()            viewState.value = DabModulatingRtuViewState.fromProfileConfig(profileConfiguration)            CcuLog.i(Domain.LOG_TAG,                "Active dabFullyModulatingAhu profile config loaded $profileConfiguration"            )        } else {            profileConfiguration = DabModulatingRtuProfileConfig(model).getDefaultConfiguration()            viewState.value = DabModulatingRtuViewState.fromProfileConfig(profileConfiguration)            CcuLog.i(Domain.LOG_TAG, "Default dabFullyModulatingAhu profile config Loaded")        }        initialPortValues = HashMap(profileConfiguration.unusedPorts)        viewState.value.isSaveRequired = !systemEquip["profile"].toString().contentEquals("dabFullyModulatingAhu")    }    override fun saveConfiguration() {        hayStack.resetCcuReady()        var systemEquipId : String? = null        viewState.value.updateConfigFromViewState(profileConfiguration)        if (!checkConfigValidity()) {            viewState.value.isSaveRequired = true            viewState.value.isStateChanged = true            return        }        if(BuildConfig.BUILD_TYPE == CARRIER_PROD){            ProgressDialogUtils.showProgressDialog(context,"Saving VVT-C Configuration")        } else {            ProgressDialogUtils.showProgressDialog(context, "Saving DAB Configuration")        }        viewModelScope.launch (highPriorityDispatcher) {            val systemEquip = hayStack.readEntity(CommonQueries.SYSTEM_PROFILE)            if (systemEquip["profile"].toString() != "dabFullyModulatingAhu"                && systemEquip["profile"].toString() != ProfileType.SYSTEM_DAB_ANALOG_RTU.name            ) {                CcuLog.d(Tags.ADD_REMOVE_PROFILE, "DabModulatingRtuViewModel removing profile with it -->${systemEquip["id"].toString()}")                deleteSystemProfile(systemEquip["id"].toString())                systemEquipId = createNewEquip(systemEquip["id"].toString())                L.ccu().systemProfile!!.deleteSystemEquip()                L.ccu().systemProfile = DabFullyModulatingRtu()                L.ccu().systemProfile.removeSystemEquipModbus()                L.ccu().systemProfile.removeSystemEquipBacnet()                L.ccu().systemProfile.addSystemEquip()                CcuLog.i(Domain.LOG_TAG, profileConfiguration.toString())                UnusedPortsModel.saveUnUsedPortStatusOfSystemProfile(                    profileConfiguration,                    hayStack                )                profileConfiguration.unusedPorts.clear()                profileConfiguration.unusedPorts = ControlMote.getCMUnusedPorts(Domain.hayStack)                viewState.value.unusedPortState = profileConfiguration.unusedPorts            }else{                super.saveConfiguration()            }            withContext(Dispatchers.Main) {                ProgressDialogUtils.hideProgressDialog()            }            updateDabSystemMode()            systemEquipId?.let {                L.ccu().systemProfile.updateAhuRef(it)            }            updateOaoPoints()            val modulatingRtu = L.ccu().systemProfile as DabFullyModulatingRtu            modulatingRtu.refreshSystemEquip()            DesiredTempDisplayMode.setSystemModeForDab(hayStack)            hayStack.syncEntityTree()            hayStack.setCcuReady()            initialPortValues = HashMap(profileConfiguration.unusedPorts)            setFanTypeToStages(profileConfiguration)        }    }    override fun sendAnalogRelayTestSignal(tag: String, value: Double) {        Globals.getInstance().setTestMode(true)        if (tag.contains("analog")) {            when(tag){                DomainName.analog1Out ->                    Domain.cmBoardDevice.analog1Out.writeHisVal(value)                DomainName.analog2Out ->                    Domain.cmBoardDevice.analog2Out.writeHisVal(value)                DomainName.analog3Out ->                    Domain.cmBoardDevice.analog3Out.writeHisVal(value)                DomainName.analog4Out ->{                    Domain.cmBoardDevice.analog4Out.writeHisVal(value)                }            }        } else if (tag.contains("relay")) {            ControlMote.setRelayState(tag, value)        }        MeshUtil.sendStructToCM(DeviceUtil.getCMControlsMessage())    }    fun reset() {        val systemEquip = hayStack.readEntity(CommonQueries.SYSTEM_PROFILE)        if (systemEquip["profile"].toString() == "dabFullyModulatingAhu"            || systemEquip["profile"].toString() == ProfileType.SYSTEM_DAB_ANALOG_RTU.name        ) {            profileConfiguration = DabModulatingRtuProfileConfig(model).getActiveConfiguration()            CcuLog.i(Domain.LOG_TAG, "Active dabFullyModulatingAhu profile config Loaded")        }else{            profileConfiguration = DabModulatingRtuProfileConfig(model).getDefaultConfiguration()            CcuLog.i(Domain.LOG_TAG, "Default dabFullyModulatingAhu profile config Loaded")        }        viewState.value = DabModulatingRtuViewState.fromProfileConfig(profileConfiguration)        viewState.value.isSaveRequired = !systemEquip["profile"].toString().contentEquals("dabFullyModulatingAhu")    }    fun hasUnsavedChanges(): Boolean {        return try {            val newConfiguration = DabModulatingRtuProfileConfig(model).getDefaultConfiguration()            viewState.value.updateConfigFromViewState(newConfiguration)            return hasChanges(                profileConfiguration,                newConfiguration            ) || (initialPortValues.toMap() != viewState.value.unusedPortState.toMap())        } catch (e: Exception) {            false        }    }    fun resetDcwbConfig() {        if (viewState.value.analog1OutputAssociation != ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal            && viewState.value.analog2OutputAssociation != ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal            && viewState.value.analog3OutputAssociation != ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal            && viewState.value.analog4OutputAssociation != ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal) {            viewState.value.isDcwbEnabled = false        }    }    private fun checkConfigValidity(): Boolean {        val compressorAvailable =  profileConfiguration.isAnyAnalogMappedToCompressor()        val changeOverCooling =            profileConfiguration.isAnyRelayEnabledAndMapped(ModulatingProfileRelayMapping.CHANGE_OVER_COOLING.ordinal)        val changeOverHeating =            profileConfiguration.isAnyRelayEnabledAndMapped(ModulatingProfileRelayMapping.CHANGE_OVER_HEATING.ordinal)        if (compressorAvailable) {            if (!changeOverCooling && !changeOverHeating) {                showErrorDialog(                    context,                    Html.fromHtml(                        "<b>The compressor is mapped, but the O/B changeover relay is not mapped.</b>",                        Html.FROM_HTML_MODE_LEGACY                    )                ){ viewState.value.isStateChanged = true; }                return false            }            if (changeOverCooling && changeOverHeating) {                showErrorDialog(                    context,                    Html.fromHtml(                        "<b>The O/B changeover relay is mapped for both cooling and heating. Please select only one.</b>",                        Html.FROM_HTML_MODE_LEGACY                    )                ){ viewState.value.isStateChanged = true; }                return false            }        } else {            if (changeOverCooling || changeOverHeating) {                showErrorDialog(                    context,                    Html.fromHtml(                        "<b>The O/B changeover relay is mapped, but the compressor is not mapped.</b>",                        Html.FROM_HTML_MODE_LEGACY                    )                )                return false            }        }        return true    }    fun checkDcwbBtuMeterStatus(): Boolean {        val valveSelected = viewState.value.isAnalog1OutputEnabled && viewState.value.analog1OutputAssociation == ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal                || viewState.value.isAnalog2OutputEnabled && viewState.value.analog2OutputAssociation == ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal                || viewState.value.isAnalog3OutputEnabled && viewState.value.analog3OutputAssociation == ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal                || viewState.value.isAnalog4OutputEnabled && viewState.value.analog4OutputAssociation == ModulatingProfileAnalogMapping.ChilledWaterValve.ordinal        if (!valveSelected) {            CcuLog.i(Domain.LOG_TAG, "Valve not selected. Disable DCWB")            viewState.value.isDcwbEnabled = false        }        return valveSelected && !viewState.value.isDcwbEnabled    }}